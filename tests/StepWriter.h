#pragma once
// Simple STEP writer used only by tests to produce visual debug output.
// Writes geometry as a FACETED_BREP in ISO 10303-21 (STEP AP203) format.

#include "gk/math/Vec3.h"
#include "gk/surface/SurfaceUtils.h"
#include <array>
#include <filesystem>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>

// Returns "step_test_output/<filename>" and ensures the directory exists.
inline std::string stepOutputPath(const std::string& filename) {
    std::filesystem::create_directories("step_test_output");
    return "step_test_output/" + filename;
}

class StepWriter {
public:
    StepWriter() = default;

    void addVertex(gk::Vec3 v) { vertices_.push_back(v); }

    void addFace(int v1, int v2, int v3) {
        faces_.push_back({v1, v2, v3});
    }

    void addSurfaceMesh(const gk::SurfaceMesh& mesh) {
        int vOffset = static_cast<int>(vertices_.size());
        for (auto& v : mesh.vertices) vertices_.push_back(v);
        for (auto& tri : mesh.triangles)
            addFace(tri[0] + vOffset, tri[1] + vOffset, tri[2] + vOffset);
    }

    bool write(const std::string& path) {
        std::ofstream f(path);
        if (!f.is_open()) return false;

        std::ostringstream data;
        int nextId = 1;

        // CARTESIAN_POINT per vertex
        std::vector<int> ptIds;
        ptIds.reserve(vertices_.size());
        for (auto& v : vertices_) {
            ptIds.push_back(nextId);
            data << "#" << nextId++ << "=CARTESIAN_POINT('',("
                 << v.x << "," << v.y << "," << v.z << "));\n";
        }

        // POLY_LOOP + FACE_BOUND + ADVANCED_FACE per triangle
        std::vector<int> faceIds;
        faceIds.reserve(faces_.size());
        for (auto& tri : faces_) {
            int loopId  = nextId++;
            data << "#" << loopId << "=POLY_LOOP('',("
                 << "#" << ptIds[tri[0]] << ","
                 << "#" << ptIds[tri[1]] << ","
                 << "#" << ptIds[tri[2]] << "));\n";
            int boundId = nextId++;
            data << "#" << boundId << "=FACE_BOUND('',#" << loopId << ",.T.);\n";
            int faceId  = nextId++;
            data << "#" << faceId
                 << "=ADVANCED_FACE('',(" << "#" << boundId << "),$,.T.);\n";
            faceIds.push_back(faceId);
        }

        // CLOSED_SHELL
        int shellId = nextId++;
        data << "#" << shellId << "=CLOSED_SHELL('',(";
        for (int i = 0; i < static_cast<int>(faceIds.size()); ++i) {
            if (i > 0) data << ",";
            data << "#" << faceIds[i];
        }
        data << "));\n";

        // FACETED_BREP
        int brepId = nextId++;
        data << "#" << brepId << "=FACETED_BREP('',#" << shellId << ");\n";

        // Full ISO 10303-21 file
        f << "ISO-10303-21;\n"
          << "HEADER;\n"
          << "FILE_DESCRIPTION(('Generated by GectorTest'),'2;1');\n"
          << "FILE_NAME('" << path << "','',(''),(''),'Gector','','');\n"
          << "FILE_SCHEMA(('CONFIG_CONTROL_DESIGN'));\n"
          << "ENDSEC;\n"
          << "DATA;\n"
          << data.str()
          << "ENDSEC;\n"
          << "END-ISO-10303-21;\n";
        return true;
    }

private:
    std::vector<gk::Vec3>           vertices_;
    std::vector<std::array<int, 3>> faces_;
};
