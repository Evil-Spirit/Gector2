#pragma once
// Chapter 9.1 — STEP AP203 export for solid Body entities.
//
// Writes a Body as a FACETED_BREP in ISO 10303-21 (STEP AP203) format.
// Each face surface is tessellated at the requested grid resolution so the
// output can be opened by FreeCAD, CAD viewers, and other STEP-compliant tools.

#include "gk/brep/Body.h"
#include "gk/surface/SurfaceUtils.h"
#include <array>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>

namespace gk {

class StepExport
{
public:
    // ── Public API ────────────────────────────────────────────────────────────

    /// Write a Body to an ISO 10303-21 STEP AP203 string.
    /// Each face surface is tessellated with tessSteps × tessSteps quads.
    static std::string writeBody(const Body& body, int tessSteps = 8)
    {
        std::vector<Vec3>               vertices;
        std::vector<std::array<int, 3>> faces;

        for (auto& lump : body.lumps()) {
            if (!lump || !lump->outerShell()) continue;
            for (auto& face : lump->outerShell()->faces()) {
                if (!face || !face->hasSurface()) continue;
                auto mesh   = tessellate(*face->surface(), tessSteps, tessSteps);
                int  vOff   = static_cast<int>(vertices.size());
                for (auto& v : mesh.vertices)
                    vertices.push_back(v);
                for (auto& tri : mesh.triangles)
                    faces.push_back({tri[0] + vOff,
                                     tri[1] + vOff,
                                     tri[2] + vOff});
            }
        }

        return buildStepText(vertices, faces);
    }

    /// Write a Body directly to a STEP file.  Returns true on success.
    static bool writeBodyToFile(const Body& body,
                                const std::string& path,
                                int tessSteps = 8)
    {
        std::string text = writeBody(body, tessSteps);
        std::ofstream f(path);
        if (!f.is_open()) return false;
        f << text;
        return true;
    }

private:
    // ── ISO 10303-21 builder ─────────────────────────────────────────────────

    static std::string buildStepText(
        const std::vector<Vec3>&               vertices,
        const std::vector<std::array<int, 3>>& faces)
    {
        std::ostringstream data;
        int nextId = 1;

        // CARTESIAN_POINT for each vertex
        std::vector<int> ptIds;
        ptIds.reserve(vertices.size());
        for (auto& v : vertices) {
            ptIds.push_back(nextId);
            data << "#" << nextId++ << "=CARTESIAN_POINT('',("
                 << v.x << "," << v.y << "," << v.z << "));\n";
        }

        // One POLY_LOOP + FACE_BOUND + ADVANCED_FACE per triangle
        std::vector<int> faceIds;
        faceIds.reserve(faces.size());
        for (auto& tri : faces) {
            int loopId  = nextId++;
            data << "#" << loopId << "=POLY_LOOP('',("
                 << "#" << ptIds[tri[0]] << ","
                 << "#" << ptIds[tri[1]] << ","
                 << "#" << ptIds[tri[2]] << "));\n";
            int boundId = nextId++;
            data << "#" << boundId << "=FACE_BOUND('',#" << loopId << ",.T.);\n";
            int faceId  = nextId++;
            data << "#" << faceId
                 << "=ADVANCED_FACE('',(" << "#" << boundId << "),$,.T.);\n";
            faceIds.push_back(faceId);
        }

        // CLOSED_SHELL collecting all faces
        int shellId = nextId++;
        data << "#" << shellId << "=CLOSED_SHELL('',(";
        for (int i = 0; i < static_cast<int>(faceIds.size()); ++i) {
            if (i > 0) data << ",";
            data << "#" << faceIds[i];
        }
        data << "));\n";

        // FACETED_BREP referencing the shell
        int brepId = nextId++;
        data << "#" << brepId << "=FACETED_BREP('',#" << shellId << ");\n";

        // Assemble the full ISO 10303-21 file
        std::ostringstream os;
        os << "ISO-10303-21;\n"
           << "HEADER;\n"
           << "FILE_DESCRIPTION(('Generated by Gector'),'2;1');\n"
           << "FILE_NAME('','',(''),(''),'Gector Kernel','','');\n"
           << "FILE_SCHEMA(('CONFIG_CONTROL_DESIGN'));\n"
           << "ENDSEC;\n"
           << "DATA;\n"
           << data.str()
           << "ENDSEC;\n"
           << "END-ISO-10303-21;\n";
        return os.str();
    }
};

} // namespace gk
