#pragma once
// Iteration 1.4 — EntityId: opaque 64-bit stable identifier.
//
// Properties:
//   * Generated by EntityId::generate() using a global atomic counter.
//   * Id 0 is reserved as the "invalid" sentinel.
//   * Ids are never reused within a process lifetime.

#include <atomic>
#include <cstdint>
#include <string>

namespace gk {

class EntityId
{
public:
    using IdType = std::uint64_t;

    // ── Factory ───────────────────────────────────────────────────────────────

    /// Returns a new, unique, non-zero EntityId.  Thread-safe.
    static EntityId generate() noexcept
    {
        return EntityId{nextId_.fetch_add(1, std::memory_order_relaxed)};
    }

    /// The invalid (null) sentinel.
    static constexpr EntityId invalid() noexcept { return EntityId{0}; }

    // ── Construction (default = invalid) ──────────────────────────────────────
    constexpr EntityId() noexcept = default;

    // ── Observers ─────────────────────────────────────────────────────────────
    constexpr bool   isValid() const noexcept { return id_ != 0; }
    constexpr IdType value()   const noexcept { return id_;       }

    // ── Comparison ────────────────────────────────────────────────────────────
    constexpr bool operator==(const EntityId& o) const noexcept { return id_ == o.id_; }
    constexpr bool operator!=(const EntityId& o) const noexcept { return id_ != o.id_; }
    constexpr bool operator< (const EntityId& o) const noexcept { return id_ <  o.id_; }

    // ── Serialization ─────────────────────────────────────────────────────────
    std::string toString() const
    {
        return "EntityId(" + std::to_string(id_) + ")";
    }

private:
    constexpr explicit EntityId(IdType id) noexcept : id_(id) {}

    IdType id_{0};

    /// Global counter; starts at 1 so that 0 is always "invalid".
    static inline std::atomic<IdType> nextId_{1}; // C++17 inline static
};

} // namespace gk
